<!DOCTYPE html>
<html lang="it-IT">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="hiddenproof"><h3 class="heading"><span class="type">Dimostrazione</span></h3>
<div class="para">Dalla <a href="" class="xref" data-knowl="./knowl/prop-classe_equivalenza.html" title="Proposizione 2.2.7">Proposizione 2.2.7</a>, la classe <span class="process-math">\(\class[\sim]{a}\)</span> contiene l'elemento <span class="process-math">\(a\text{:}\)</span> in particolare, ogni classe è non vuota e ogni elemento di <span class="process-math">\(A\)</span> è contenuto in (almeno) una classe, da cui segue che l'unione delle classi è uguale ad <span class="process-math">\(A\text{.}\)</span> La <a href="" class="xref" data-knowl="./knowl/prop-classe_equivalenza.html" title="Proposizione 2.2.7">Proposizione 2.2.7</a> afferma inoltre che classi distinte hanno intersezione vuota. Pertanto, le classi formano una partizione.</div> <div class="para">Viceversa, data la partizione <span class="process-math">\(\{C_{i}\}_{i\in I}\text{,}\)</span> definiamo la relazione <span class="process-math">\(\approx\)</span> così: <span class="process-math">\(a\approx b\)</span> se esiste <span class="process-math">\(i\in I\)</span> tale che <span class="process-math">\(a\in C_{i}\)</span> e <span class="process-math">\(b\in C_{i}\text{.}\)</span> La relazione <span class="process-math">\(\approx\)</span> è chiaramente simmetrica. Poiché <span class="process-math">\(\bigcup_{i\in I}C_{i}=A\text{,}\)</span> per ogni <span class="process-math">\(a\in A\)</span> esiste un <span class="process-math">\(i\in I\)</span> tale che <span class="process-math">\(a\in C_{i}\text{:}\)</span> dunque, <span class="process-math">\(\approx\)</span> è riflessiva. Infine, se <span class="process-math">\(a\approx b\)</span> e <span class="process-math">\(b\approx c\text{,}\)</span> allora esistono <span class="process-math">\(i\)</span> e <span class="process-math">\(j\)</span> in <span class="process-math">\(I\)</span> tali che <span class="process-math">\(a\in C_{i}\text{,}\)</span> <span class="process-math">\(b\in C_{i}\text{,}\)</span> <span class="process-math">\(b\in C_{j}\)</span> e <span class="process-math">\(c\in C_{j}\text{.}\)</span> Dunque, <span class="process-math">\(C_{i}\cap C_{j}\)</span> contiene <span class="process-math">\(b\)</span> ed è, quindi, non vuoto: per definizione di partizione, ciò significa che <span class="process-math">\(i=j\)</span> e, di conseguenza, c'è un elemento della partizione che contiene sia <span class="process-math">\(a\)</span> che <span class="process-math">\(c\)</span> e, pertanto, <span class="process-math">\(a\approx c\text{,}\)</span> cioè <span class="process-math">\(\approx\)</span> è transitiva. Dato <span class="process-math">\(a\)</span> in <span class="process-math">\(A\text{,}\)</span> gli elementi a esso equivalenti sono tutti e soli quelli appartenenti all'unico <span class="process-math">\(C_{i}\)</span> contenente <span class="process-math">\(a\text{,}\)</span> cioè la classe di equivalenza di <span class="process-math">\(a\)</span> coincide con <span class="process-math">\(C_{i}\text{.}\)</span>
</div></article><span class="incontext"><a href="sec-relazioni_equivalenza.html#proof-3" class="internal">Contesto</a></span>
</body>
</html>
